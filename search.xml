<?xml version="1.0" encoding="utf-8"?>
<search> 
  
    
    <entry>
      <title><![CDATA[cdecl for C code 描述宣告]]></title>
      <url>/2017/07/02/c-code-cdecl/</url>
      <content type="html"><![CDATA[<p>在<a href="https://hackmd.io/s/HJFyt37Mx#" target="_blank" rel="external">Jserv 的開發工具與規格內</a> 內提到一個可以用轉換工具,可以將C code 宣告轉換成英文描述,跟英文描述轉換成code宣告格式,方便我們解讀文章所是如何用說的將宣告描述出來 透過<code>cdecl</code></p>
<h2 id="Install"><a href="#Install" class="headerlink" title="Install"></a>Install</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install cdecl</div></pre></td></tr></table></figure>
<h2 id="Example"><a href="#Example" class="headerlink" title="Example"></a>Example</h2><p>En To Code </p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cdecl&gt; declare a as array of pointer to function returning pointer to function returning pointer to char</div><div class="line"></div><div class="line">char *(*(*a[])())()</div></pre></td></tr></table></figure>
<p>Code To En</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">cdecl&gt; explain char *(*fptab[])(int)</div><div class="line"></div><div class="line">declare fptab as array of pointer to function (int) returning pointer to char</div></pre></td></tr></table></figure>
]]></content>
      
        
        <tags>
            
            <tag> C_code </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[How to use LD_PRELOAD]]></title>
      <url>/2017/06/17/LD-PRELOAD-use/</url>
      <content type="html"><![CDATA[<p>這邊是聽jserv 的線上講座<a href="https://hackmd.io/s/HkK7Uf4Ml#" target="_blank" rel="external">你所不知道的 C 語言：動態連結器篇</a> 才知道的方式<br>爲了怕忘記做些測試候的記錄<br>這邊用的範例也是base on jserv的範例做修改測試 </p>
<h1 id="LD-PRELOAD"><a href="#LD-PRELOAD" class="headerlink" title="LD_PRELOAD"></a>LD_PRELOAD</h1><p>透過在執行檔案之前加上 LD_PRELOAD=xxx.so 可以將後面執行程式所呼叫的function取代成xxx.so內的function<br>也就是我們可以做到替換libc內的函式 改成我們自己的 <code>當程式執行時</code></p>
<p><a href="https://github.com/shihyu/Linux_Programming/tree/master/example/%E7%94%A8LD_PRELOAD%E6%9B%BF%E6%8F%9B%E5%8B%95%E6%85%8B%E9%80%A3%E7%B5%90%E7%9A%84%E5%87%BD%E5%BC%8F%E5%BA%AB" target="_blank" rel="external">github 上面也有人寫相關資料</a></p>
<h1 id="測試"><a href="#測試" class="headerlink" title="測試"></a>測試</h1><p>目標是將malloc and free 替換成自己的library 當執行測試檔時,code 的內容如下</p>
<h3 id="malloc-count-c"><a href="#malloc-count-c" class="headerlink" title="malloc_count.c"></a>malloc_count.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div></pre></td><td class="code"><pre><div class="line">#include &lt;stddef.h&gt;</div><div class="line">#include &lt;dlfcn.h&gt;</div><div class="line">void *malloc(size_t size)</div><div class="line">&#123;</div><div class="line">    char buf[32];</div><div class="line">    static void *(*real_malloc)(size_t) = NULL;</div><div class="line">    if (real_malloc == NULL) &#123;</div><div class="line">        real_malloc = dlsym(RTLD_NEXT, &quot;malloc&quot;);</div><div class="line">    &#125;</div><div class="line">    sprintf(buf, &quot;malloc called, size = %zu\n&quot;, size);</div><div class="line">    write(2, buf, strlen(buf));</div><div class="line">    return real_malloc(size);</div><div class="line">&#125;</div><div class="line"></div><div class="line">void *free(void *ptr)</div><div class="line">&#123;</div><div class="line">    char buf[32];</div><div class="line">    static void *(*real_free)(void *ptr) = NULL;</div><div class="line">    if (real_free == NULL) &#123;</div><div class="line">        real_free = dlsym(RTLD_NEXT, &quot;free&quot;);</div><div class="line">    &#125;</div><div class="line">    sprintf(buf, &quot;free called, ptr address = %x\n&quot;, ptr);</div><div class="line">    write(2, buf, strlen(buf));</div><div class="line">	real_free(ptr);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<h3 id="test-c"><a href="#test-c" class="headerlink" title="test.c"></a>test.c</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">#include &lt;stdio.h&gt;</div><div class="line">#include &lt;stdlib.h&gt;</div><div class="line">#include &lt;string.h&gt;</div><div class="line"></div><div class="line">void main(void)</div><div class="line">&#123;</div><div class="line">	char *buffer;</div><div class="line"></div><div class="line">	buffer = malloc(sizeof(char)*10);</div><div class="line">	memset(buffer, 0x41, 10);</div><div class="line">	puts(buffer);</div><div class="line">	free(buffer);</div><div class="line">	buffer = NULL;</div><div class="line">	free(buffer);</div><div class="line">&#125;</div></pre></td></tr></table></figure>
<p>編譯command :<br>原本用的command 跟講座上面是一樣的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -D_GNU_SOURCE -Wall -shared -ldl -fPIC -o libmcount.so malloc_count.c</div></pre></td></tr></table></figure></p>
<p>編譯之後透過ls測試也是可以跑的<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div></pre></td><td class="code"><pre><div class="line">memory_test$ LD_PRELOAD=libmcount.so ls</div><div class="line">malloc called, size = 568</div><div class="line">malloc called, size = 120</div><div class="line">free called, ptr address = 136a250</div><div class="line">free called, ptr address = 136a010</div><div class="line">free called, ptr address = 0</div><div class="line">malloc called, size = 5</div><div class="line">free called, ptr address = 136a010</div><div class="line">malloc called, size = 120</div><div class="line">malloc called, size = 12</div><div class="line">malloc called, size = 784</div><div class="line">malloc called, size = 112</div><div class="line">malloc called, size = 952</div><div class="line">malloc called, size = 216</div></pre></td></tr></table></figure></p>
<p>但是跑test 測試程式會出現library 找不到的問題<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">gcc -o test test.c</div><div class="line">memory_test$ LD_PRELOAD=libmcount.so ./test</div><div class="line">./test: symbol lookup error: libmcount.so: undefined symbol: dlsym</div></pre></td></tr></table></figure></p>
<p>透過ldd 發現缺少dl library<br><img src="/images/C_code/ld_preload_1.png" alt=""></p>
<p>檢查ls and test 執行檔 可以發現ls有linker ld library但是test沒有, 這也是爲何ls可以跑<br><img src="/images/C_code/ld_preload_3.png" alt=""></p>
<p>猜測因該是compiler最佳化之後將librar去除掉了  查看網路上有人說<code>-ldl</code>拉到最後面就可以<br>修改後做測試確定test可以跑了<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gcc -D_GNU_SOURCE -Wall -shared -fPIC -o libmcount.so malloc_count.c -ldl</div></pre></td></tr></table></figure></p>
<p><img src="/images/C_code/ld_preload_2.png" alt=""></p>
<p><img src="/images/C_code/ld_preload_4.png" alt=""></p>
<p>&lt;注意&gt; </p>
<ol>
<li>lbrary compiler時需要加上<code>-D_GNU_SOURCE</code> 是因爲library有用到RTLD_NEXT</li>
<li>free pointer 之後需要將pointer 設爲null 這樣在後面如果不小心再free 到時才不會有double free message<br><code>double free or corruption</code><br>C手冊上面有這一段<br><img src="/images/C_code/ld_preload_5.png" alt=""></li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> C </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Fix hexo server 啓動時 sass fail]]></title>
      <url>/2017/06/17/hexo-error-sass/</url>
      <content type="html"><![CDATA[<p>這個問題是啓動hexo server時 看到有error message<br><img src="/images/hexo_3.png" alt=""></p>
<p>在網路上面搜尋到解法是更新sass<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install --save hexo-renderer-sass@^0.1</div></pre></td></tr></table></figure></p>
<p>不過我這邊安裝前後比對hexo相關版本的值是沒有變化的 不過問題是解掉了</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div></pre></td><td class="code"><pre><div class="line">hexo version</div><div class="line">hexo: 3.3.5</div><div class="line">hexo-cli: 1.0.2</div><div class="line">os: Linux 3.13.0-37-generic linux x64</div><div class="line">http_parser: 2.3</div><div class="line">node: 0.12.7</div><div class="line">v8: 3.28.71.19</div><div class="line">uv: 1.6.1</div><div class="line">zlib: 1.2.8</div><div class="line">modules: 14</div><div class="line">openssl: 1.0.1p</div></pre></td></tr></table></figure>
<p><a href="https://github.com/knksmith57/hexo-renderer-sass/issues/7" target="_blank" rel="external">參考資料</a></p>
]]></content>
      
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Ubuntu enable samba]]></title>
      <url>/2017/06/17/ubuntu-samba/</url>
      <content type="html"><![CDATA[<p>目前我是透過samba讓實體機器Linux 跟VMwave Windows可以互相傳資料<br>之前samba設定錯誤一直沒有設定權限 這邊記錄一下怎樣設定</p>
<h2 id="install-samba-on-Ubuntu"><a href="#install-samba-on-Ubuntu" class="headerlink" title="install samba on Ubuntu"></a>install samba on Ubuntu</h2><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo apt-get install samba</div></pre></td></tr></table></figure>
<h2 id="create-account-for-samba-user"><a href="#create-account-for-samba-user" class="headerlink" title="create account for samba user"></a>create account for samba user</h2><p>這邊目的是建立一個專屬的可以用samba的account 當然如果懶惰也可以直接用你現有的account 就跳過下一個步驟<br>create addount : <code>sudo adduser smbuser</code></p>
<p>新增使用者並同時設定這個使用者的 Samba 登人密碼 ： <code>sudo smbpasswd -a smbuser</code></p>
<p>輸入完密碼之後就可以修改<code>/etc/samba/smb.conf</code> 添加範例如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">[global]</div><div class="line">security = user  #enable security, 設share 就沒有password request</div><div class="line"></div><div class="line">[share_file]  # share_file 名稱可以自行變更主要是顯示給外面透過search的人看的</div><div class="line">path = /home/smbuser # 這個是要分享的資料夾路徑</div><div class="line">available = yes</div><div class="line">valid users = smbuser # 這個是可以使用這個分享資料夾的使用者，要具有 path 所指定的路徑的權限才行</div><div class="line">read only = no</div><div class="line">#public = yes</div><div class="line">writable = yes</div><div class="line">browseable = yes # 在透過window 打\\your_IP後支援可以被搜尋到</div><div class="line">encrypt passwords = yes # 密碼傳送時要加密 </div><div class="line">smb passwd file = /etc/samba/smbpasswd #password save path</div></pre></td></tr></table></figure>
<p>重新啟動 Samba Server<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo /etc/init.d/samba restart</div></pre></td></tr></table></figure></p>
<p>可以透過testparm來檢查設定是否有問題 會顯示如下:<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div></pre></td><td class="code"><pre><div class="line">Load smb config files from /etc/samba/smb.conf</div><div class="line">rlimit_max: increasing rlimit_max (1024) to minimum Windows limit (16384)</div><div class="line">Processing section &quot;[tmp]&quot;</div><div class="line">Global parameter encrypt passwords found in service section!</div><div class="line">Global parameter smb passwd file found in service section!</div><div class="line">Loaded services file OK.</div><div class="line">WARNING: &apos;workgroup&apos; and &apos;netbios name&apos; must differ.</div><div class="line">Server role: ROLE_STANDALONE</div><div class="line">Press enter to see a dump of your service definitions</div></pre></td></tr></table></figure></p>
]]></content>
      
        
        <tags>
            
            <tag> Samba </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[IOS Swift 基本學習]]></title>
      <url>/2017/06/04/swift-study/</url>
      <content type="html"><![CDATA[<p>Swift是apple 提供的一個開法在ISO跟OS X上AP的工具 根據官網描述 是一個具有高開發跟效能的語言<br>Swift是base on cocoa跟cocoa touch框架<br>網路上有好心人放上翻譯的文件<a href="https://tommy60703.gitbooks.io/swift-language-traditional-chinese/content/chapter1/01_swift.html" target="_blank" rel="external">swift 中文翻譯檔</a><br>2017 apple 將Swift open出來 在pad上面有AP可以學習 並且有提供linux上面可以跑的bin file</p>
<h2 id="安裝在-Linux"><a href="#安裝在-Linux" class="headerlink" title="安裝在 Linux"></a>安裝在 Linux</h2><p>First, install clang:<br><code>$ sudo apt-get install clang</code><br><a href="https://swift.org/download/#snapshots" target="_blank" rel="external">apple Swift file</a> Apple 在網路上提供Ubuntu 14.04跟 16.04 16.10版本可執行檔</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">tar -jxvf swift-3.1.1-RELEASE-ubuntu14.04.tar.gz</div><div class="line">export PATH=[youre folder path]/swift-3.1.1-RELEASE-ubuntu14.04/usr/bin:$&#123;PATH&#125;</div><div class="line">$ swift -version</div><div class="line">&gt; Swift version 3.1.1 (swift-3.1.1-RELEASE)</div><div class="line">&gt; Target: x86_64-unknown-linux-gnu</div></pre></td></tr></table></figure>
<p>基本上解開檔案增加bin file path 到PATH下就可以使用了<br>目前最新的版本是3.1.1</p>
<h2 id="Run-Swift"><a href="#Run-Swift" class="headerlink" title="Run Swift"></a>Run Swift</h2><p>Swift 有提供read-eval-print Loop(REPL)開發環境 當你純粹打swift後面沒有接任何參數時會進去<br><img src="/images/swift_1.png" alt=""></p>
<p>你可執行基本的運算或編程跟python一樣 例如<br><img src="/images/swift_2.png" alt=""><br><img src="/images/swift_3.png" alt=""></p>
<p>另外可以透過<tab>鍵查到相關function name, command 如下<br><code>&quot;hi!&quot;.re&lt;tab&gt;</code><br><img src="/images/swift_4.png" alt=""></tab></p>
<p>離開REPL command <code>:exit</code> <code>:q</code><br><img src="/images/swift_5.png" alt=""></p>
<h2 id="Build-an-executable"><a href="#Build-an-executable" class="headerlink" title="Build an executable"></a>Build an executable</h2><h3 id="Create-command"><a href="#Create-command" class="headerlink" title="Create command"></a>Create command</h3><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">mkdir Test</div><div class="line">cd Test</div><div class="line">swift package init --type executable</div></pre></td></tr></table></figure>
<p><img src="/images/swift_6.png" alt=""></p>
<h3 id="build-package"><a href="#build-package" class="headerlink" title="build package"></a>build package</h3><p><code>swift build</code><br>產生的執行檔在<code>.build\debug</code>下面</p>
<p><img src="/images/swift_7.png" alt=""></p>
<h2 id="Debug-support"><a href="#Debug-support" class="headerlink" title="Debug support"></a>Debug support</h2><p>Swift 可以透過LLDB debug</p>
<p>LLDB is the default debugger in Xcode on Mac OS X and supports debugging C, Objective-C and C++ on the desktop and iOS devices and simulator.</p>
<p>透過<code>swiftc -g ***.swift</code> 產生debug要用的檔案 再透過<code>lldb ***</code> 去執行debug</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div></pre></td><td class="code"><pre><div class="line">luna@luna-ubuntu14:Test$ cat Sources/main.swift </div><div class="line">print(&quot;Hello, world!&quot;)</div><div class="line">func factor(n: Int) -&gt; Int&#123;</div><div class="line">	if n &lt;= 1 &#123;return n&#125;</div><div class="line">	return n * factor(n: n-1)</div><div class="line">&#125;</div><div class="line">let number = 5</div><div class="line">print(&quot;\(number)! is equal to \(factor(n: number))&quot;)</div><div class="line">luna@luna-ubuntu14:Test$ swiftc -g Sources/main.swift </div><div class="line">luna@luna-ubuntu14:Test$ ls</div><div class="line">main  Package.swift  Sources  Tests</div><div class="line">luna@luna-ubuntu14:Test$ ls Sources/</div><div class="line">main.swift</div></pre></td></tr></table></figure>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div><div class="line">16</div><div class="line">17</div><div class="line">18</div><div class="line">19</div><div class="line">20</div><div class="line">21</div><div class="line">22</div><div class="line">23</div><div class="line">24</div><div class="line">25</div><div class="line">26</div><div class="line">27</div><div class="line">28</div><div class="line">29</div><div class="line">30</div><div class="line">31</div><div class="line">32</div><div class="line">33</div><div class="line">34</div><div class="line">35</div><div class="line">36</div><div class="line">37</div><div class="line">38</div><div class="line">39</div><div class="line">40</div><div class="line">41</div><div class="line">42</div><div class="line">43</div><div class="line">44</div><div class="line">45</div><div class="line">46</div><div class="line">47</div><div class="line">48</div><div class="line">49</div><div class="line">50</div><div class="line">51</div><div class="line">52</div><div class="line">53</div><div class="line">54</div></pre></td><td class="code"><pre><div class="line">luna@luna-ubuntu14:Test$ lldb main </div><div class="line">(lldb) target create &quot;main&quot;</div><div class="line">Current executable set to &apos;main&apos; (x86_64).</div><div class="line">(lldb) l</div><div class="line">   1	print(&quot;Hello, world!&quot;)</div><div class="line">   2	func factor(n: Int) -&gt; Int&#123;</div><div class="line">   3		if n &lt;= 1 &#123;return n&#125;</div><div class="line">   4		return n * factor(n: n-1)</div><div class="line">   5	&#125;</div><div class="line">   6	</div><div class="line">   7	let number = 5</div><div class="line">   8	print(&quot;\(number)! is equal to \(factor(n: number))&quot;)</div><div class="line">(lldb) b 2</div><div class="line">Breakpoint 1: where = main`main.factor (n : Swift.Int) -&gt; Swift.Int + 12 at main.swift:3, address = 0x0000000000400f5c</div><div class="line">(lldb) r</div><div class="line">Process 8098 launched: &apos;/home/luna/swift/Test/main&apos; (x86_64)</div><div class="line">Hello, world!</div><div class="line">Process 8098 stopped</div><div class="line">* thread #1, name = &apos;main&apos;, stop reason = breakpoint 1.1</div><div class="line">    frame #0: 0x0000000000400f5c main`factor(n=5) -&gt; Int at main.swift:3</div><div class="line">   1	print(&quot;Hello, world!&quot;)</div><div class="line">   2	func factor(n: Int) -&gt; Int&#123;</div><div class="line">-&gt; 3		if n &lt;= 1 &#123;return n&#125;</div><div class="line">   4		return n * factor(n: n-1)</div><div class="line">   5	&#125;</div><div class="line">   6	</div><div class="line">   7	let number = 5</div><div class="line">(lldb) p n</div><div class="line">(Int) $R0 = 5</div><div class="line">(lldb) n</div><div class="line">Process 8098 stopped</div><div class="line">* thread #1, name = &apos;main&apos;, stop reason = step over</div><div class="line">    frame #0: 0x0000000000400f70 main`factor(n=5) -&gt; Int at main.swift:4</div><div class="line">   1	print(&quot;Hello, world!&quot;)</div><div class="line">   2	func factor(n: Int) -&gt; Int&#123;</div><div class="line">   3		if n &lt;= 1 &#123;return n&#125;</div><div class="line">-&gt; 4		return n * factor(n: n-1)</div><div class="line">   5	&#125;</div><div class="line">   6	</div><div class="line">   7	let number = 5</div><div class="line">(lldb) n</div><div class="line">* thread #1, name = &apos;main&apos;, stop reason = breakpoint 1.1</div><div class="line">    frame #0: 0x0000000000400f5c main`factor(n=4) -&gt; Int at main.swift:3</div><div class="line">   1	print(&quot;Hello, world!&quot;)</div><div class="line">   2	func factor(n: Int) -&gt; Int&#123;</div><div class="line">-&gt; 3		if n &lt;= 1 &#123;return n&#125;</div><div class="line">   4		return n * factor(n: n-1)</div><div class="line">   5	&#125;</div><div class="line">   6	</div><div class="line">   7	let number = 5</div><div class="line">(lldb) p n</div><div class="line">(Int) $R1 = 4</div><div class="line">(lldb) p n*n</div><div class="line">(Int) $R2 = 16</div></pre></td></tr></table></figure>
<h2 id="參考資料"><a href="#參考資料" class="headerlink" title="參考資料"></a>參考資料</h2><p><a href="https://swift.org/getting-started/#using-the-lldb-debugger" target="_blank" rel="external">Apple Swift</a></p>
]]></content>
      
        
        <tags>
            
            <tag> Swift </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[Egalax Touch i2c interface 記錄]]></title>
      <url>/2017/05/18/egalax-touch/</url>
      <content type="html"><![CDATA[<p>這次需要支援5線touch panel,硬體選擇透過egalax touch IC(MER4485XRU) 控制<br>我們用的是電阻式touch 所以必須要再做touch 校正</p>
<p>Egalax touch IC 支援界面有USB and I2C<br>在IC韌體部分有bootload and firmware 兩部分,其中firemware用來跟上層drivere溝通<br>default IC是支援USB interface , 如果要支援i2c則是bootload and firmware兩個都要支援<br>如果bootload 沒有支援可以發現INT pin不會正常low 開機也不會有 high -&gt; low -&gt; high 變化<br>另外 透過i2cTOUSB 轉板 透過i2cTOUSB 轉板<br>如果firmware 沒有支援可以發現, 開機之後 INT pin不會正常low 可以透過i2cTOUSB轉板加上Windows 程式讀出firmware </p>
<p>Egalax Touch IC 在一開機時會丟一個i2c 封包, 如果封包沒有去接受時 INT pin 會keep low </p>
<p>egalax firmware 有支援USB and i2c interface 運作方式是</p>
<ol>
<li>一上電會透過D+/D-看溝通有沒有成功去決定要不要走USB 界面<br>當USB 封包溝通沒有成功時 會導向i2c界面</li>
<li>INT 這根Pin 是有egalax 自己決定要不要拉low, 而且只有在i2c 這個interface時才會有作用<br>一上電時INT會拉上3.3v接下來egalax 會拉low ,這時候master端要去處理i2c封包 要不然會keep low狀態</li>
</ol>
<h2 id="校正方式"><a href="#校正方式" class="headerlink" title="校正方式"></a>校正方式</h2><p>在透過firmware溝通可以做到校正功能 , 這邊要注意因爲跟收touch資訊是透過i2c<br>fiemware溝通也是透過i2c 所以interrupt是共用的  kernel driver 這邊會將所有的封包都收掉<br>所以需要區分並且將跟fiemware溝通的回報值另外丟出來了到user space 這樣才有辦法處理</p>
]]></content>
      
        
        <tags>
            
            <tag> Touch </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[ARM Neon]]></title>
      <url>/2017/05/12/ARM-neon/</url>
      <content type="html"><![CDATA[<p>參考相關資料</p>
<p><a href="http://hcliao.twbbs.org/android/neon" target="_blank" rel="external">android_neon</a> <a href="http://infocenter.arm.com/help/index.jsp?topic=/com.arm.doc.dui0472k/chr1360928366062.html" target="_blank" rel="external">來源1</a><br><a href="http://www.jianshu.com/p/70601b36540f" target="_blank" rel="external">來源2</a> <a href="https://community.arm.com/processors/b/blog/posts/coding-for-neon---part-1-load-and-stores" target="_blank" rel="external">來源3</a></p>
<p>在 camera 這邊我們是透過QT Qcamera 收取影像來源 在透過QImage 去產生image 做利用<br>因為QImage 吃的格式有限制<br><a href="http://doc.qt.io/qt-5/qvideoframe.html#imageFormatFromPixelFormat" target="_blank" rel="external">QImage</a><br><strong>Note: In general QImage does not handle YUV formats.</strong><br>加上USB camera 進來會是YUYV (YUY2) 格式 IP camera 進來會是 I420p 格式<br>所以在這邊需要做格式轉換從YUV -&gt; RGB<br>可以透過QT 直接去轉換<br>在<code>CameraFrameGrabber::supportedPixelFormats</code> 這邊只有<br><code>return QVideoFrame::Format_RGB32</code><br>這樣在QT發現當下的格式不是RGB32時 會自己轉換格式<br>但是這邊造成CPU loaging太高了 約佔掉70-80％ 可以說用掉1個半CPU<br>所以我們想要利用neon指令 來優化程式效率</p>
<p>Neon 是 ARM 的SIMD 指令 (Single Instruction Multiple Data),<br>在ARM cortex 系列才有支援 主要用在media 相關的處理<br>有支援C &amp; C++ language （<code>#include &lt;arm_neon.h&gt;</code>）<br>所以可以看到有人用C 或 S 寫<br>主要register type 是D(64bits) &amp; Q(128bits), 共有D0～D32 對應到Q0~Q16<br>所以每兩個D register對應到一個Qregister</p>
<p>這邊有幾個項目需要注意一下</p>
<ol>
<li>NEON instructions execute in their own 10-stage pipeline</li>
<li>ARM can dispatch 2 NEON instructions per cycle</li>
<li>ARM → NEON register transfer is fast</li>
<li>NEON → ARM register transfer is slow</li>
<li>NEON instructions will physically execute much later than they appear to in the code</li>
<li>32 64-bit (“doubleword”) registers: d0-d31</li>
<li>16 128-bit (“quadword”) registers: q0-q15</li>
<li>qN is aliased to d(2N), d(2N+1)<ul>
<li>e.g., q0 == d0, d1</li>
</ul>
</li>
<li>q4-q7 are callee-saved<ul>
<li>VPUSH {q4-q7}</li>
<li>VPOP {q4-q7}</li>
</ul>
</li>
</ol>
<p><img src="/images/neon_1.png" alt="neon_reg"></p>
<p>在arm_neon.h 內可以看到相關的C用到的定義<br>在Neon下很重視 對齊 所以格式需要符合要求 才能做存取的動作<br>所以當不對齊時 需要做調整</p>
<pre><code>uint8x8_t vld1_u8 (const uint8_t *)
第二个字段&apos;ld&apos;表示加载指令
第三个字段&apos;1&apos;(注意是1，不是l)表示顺次加载。如果需要处理图像的
</code></pre><p>RGB分量，可能会用到vld3。关于vld/vst指令更详细的说明，请自己参阅arm官方文档。</p>
<p>從memory load to neon 跟從neon load 到memory  的方式如下:<br><img src="/images/neon_2.png" alt=""><br><img src="/images/neon_3.png" alt=""></p>
<p>＃＃YUV 格式 紀錄</p>
<p>參考資料<br><a href="https://wiki.videolan.org/YUV/#I422" target="_blank" rel="external">來源1</a> <a href="https://read01.com/jxN8QD.html" target="_blank" rel="external">來源2</a> <a href="http://blog.csdn.net/leixiaohua1020/article/details/12234821" target="_blank" rel="external">來源3</a></p>
<p>在影像儲存格式中YUV是常見的格式<br>目前確定USB camera 會用YUYV 跟MJPG<br>IP camera 有用到I420P<br>YUV，分為三個分量，「Y」表示明亮度（Luminance或Luma），也就是灰度<br>值；<br>而「U」和「V」 表示的則是色度（Chrominance或Chroma），作用是描述&gt;影像色彩及飽和度，用於指定像素的顏色。</p>
<p>與我們熟知的RGB類似，YUV也是一種顏色編碼方法，主要用於電視系統以&gt;及模擬視頻領域，它將亮度信息（Y）與色彩信息（UV）分離，沒有UV信息<br>一樣可以顯示完整的圖像，只不過是黑白的，這樣的設計很好地解決了彩&gt;色電視機與黑白電視的兼容問題。並且，YUV不像RGB那樣要求三個獨立的&gt;視頻信號同時傳輸，所以用YUV方式傳送占用極少的頻寬。<br><a href="https://read01.com/jxN8QD.html" target="_blank" rel="external">原文網址</a></p>
<p>對人類而言 亮度的感受 會比色度來的明顯<br>這是因為人眼視網膜是由兩種感光細胞組成的<br>分別是三種錐狀細胞(cone cell,以下稱CC)和一種桿狀細胞(rod cell,以&gt;下稱RC)<br>三種CC能分別感應RGB三種波長的光 負責色彩感受(這就是光學三原色的由<br>來)<br>RC則是負責亮度的感應 且RC對微光的敏感度比CC還強得多<br>這就是為什麼當你晚上在房間摸黑時 所有東西看起來都是接近黑白的 沒&gt;什麼顏色</p>
<p>YUV 的格式有分很多種排列方式<br>IP camera 用到的I420p是 YUV420p 它跟  YUV420sp在UV這邊排列方式是&gt;不一樣的<br><img src="/images/yuv_420p.png" alt="yuv420p"><br>NV12: YYYYYYYY UVUV =&gt;YUV420SP<br><img src="/images/yuv_420sp.png" alt="NV21"></p>
<p>在I420轉RGB這邊 用NEON可以大大的減少CPU loading 如下表</p>
<table>
<thead>
<tr>
<th style="text-align:center">方式</th>
<th style="text-align:center">CPU loading</th>
<th style="text-align:center">time</th>
</tr>
</thead>
<tbody>
<tr>
<td style="text-align:center">QT 轉換</td>
<td style="text-align:center">70％</td>
<td style="text-align:center">N</td>
</tr>
<tr>
<td style="text-align:center">C code(RGB24)</td>
<td style="text-align:center">40~43％</td>
<td style="text-align:center">6-14ms</td>
</tr>
<tr>
<td style="text-align:center">NEON(RGB32)</td>
<td style="text-align:center">30~32％</td>
<td style="text-align:center">2-4ms</td>
</tr>
</tbody>
</table>
<p>USB camera YUYV(YUY2)  用的排列方式是 YUYV的方式 下圖的Cb = U Cr=V<br><img src="/images/yuy2.png" alt="yuy2"></p>
<p>因為排列方式不一樣 所以用的YUV to RGB演算法耶不一樣<br>目前在網路上可以直接找到的neon yuvTOrgb 比較多得是I4202RGB NV212RGB 等<br>YUY2RGB 的部份找不到<br>有試過先轉成I420 在轉成RGB發現顏色上面會失真<br>轉的方式是保留兩個 Y 在UV這邊留下一個偶數行的部份</p>
<pre><code>int YUY2ToI420(unsigned char *in, unsigned char *out, int _width, int _height){
    long pixels = _width * _height;
    long macropixels = pixels / 2; // macropixel count
    // new size will be w * h * 3/2 -&gt; 12 bits per pixel 4:2:0
    const size_t stride = align16(_width);
    //long mpx_per_row = info.biWidth / 2;
    long mpx_per_row = stride;
    // for each macropixel
    for (int i = 0, ci = 0; i &lt; macropixels; i++){ // ci is chroma index
        // get macropixel address, order is Y0 U0 Y1 V0
        unsigned char *mpAddress = in + i * 4;

        // copy luma data
        out[i * 2] = mpAddress[0];
        out[i * 2 + 1] = mpAddress[2];
        // copy chroma data - we skip odd rows because of 4:2:0 sampling
        long row_number = i / mpx_per_row;
        if (row_number % 2 != 0) {
            out[pixels + ci] = mpAddress[1]; // shift by Y vector
            out[pixels + pixels / 4 + ci] = mpAddress[3]; // shift by Y and U vector
            ci++;
        }
    }
    return pixels * 12 / 8; // I420
}
</code></pre><p>測試過透過ffmpag libswscale 轉換 效果也不好<br><a href="http://blog.csdn.net/wenwei19861106/article/details/8702586" target="_blank" rel="external">來源1</a> <a href="http://guguclock.blogspot.tw/2009/12/ffmpeg-swscale.html" target="_blank" rel="external">來源2</a> <a href="http://www.cnblogs.com/pokerface/p/6203577.html" target="_blank" rel="external">來源3</a></p>
<pre><code>#if LIBAVCODEC_VERSION_INT &lt; AV_VERSION_INT(55,28,1)
#define av_frame_alloc  avcodec_alloc_frame
#endif
int swscale(unsigned char *p, unsigned char *rgb, int src_w, int src_h)
{
 //   const int src_w=640,src_h=480;
 //   unsigned char *rgb, *p;
    AVFrame *pFrame = av_frame_alloc();
    AVFrame *pFrameRGB = av_frame_alloc();

    avpicture_fill((AVPicture*) pFrameRGB, rgb, PIX_FMT_RGB24, src_w, src_h);
    avpicture_fill((AVPicture*) pFrame, p, PIX_FMT_YUYV422, src_w, src_h);

    struct SwsContext *img_convert_ctx = sws_getContext(src_w, src_h, PIX_FMT_YUYV422, src_w, src_h, PIX_FMT_RGB24, SWS_BICUBIC, NULL, NULL, NULL);
    sws_scale(img_convert_ctx, (uint8_t const* const*)pFrame-&gt;data, pFrame-&gt;linesize,0,src_h,pFrameRGB-&gt;data, pFrameRGB-&gt;linesize);
    sws_freeContext(img_convert_ctx);
    av_freep(&amp;pFrameRGB);
    av_freep(&amp;pFrame);
    return 0;
}
</code></pre><p>目前有做一些實驗確認 USB camera CPU loading 的問題點</p>
<ol>
<li>移除呼叫YUYVtoRGB的code 這樣測試出來 CPU loading 一樣是60％</li>
<li>在 CameraFrameGrabber::present(const QVideoFrame &amp;frame) 加上count 超過5時會直接return trun 測試出來CPU loading 一樣60％</li>
<li>將格式直接呼叫I420toRGB neon CPU loading一樣60%</li>
<li>建立一個red QImage 畫上去 不呼叫轉換的code跟memory copy<pre><code>img = QImage(640, 480, QImage::Format_RGB32);
img.fill(QColor(&quot;red&quot;));
</code></pre>CPU loading一樣57% 左右</li>
<li>拿掉 emit frameAvailable(img); CPU loading 掉到35％</li>
<li>跑qml or gstreamer,  CPU loading 是2-4％ 猜測問題點在來源(input) 目前沒有解</li>
<li>透過 mjpg_streamer 測試 USB camera 發現CPU loading 大約46％<br>所以可以大概判定是source 來源問題</li>
</ol>
]]></content>
      
        
        <tags>
            
            <tag> neon </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo Landscape themes 修改]]></title>
      <url>/2017/05/12/hexo-themes/</url>
      <content type="html"><![CDATA[<p>在<a href="https://hexo.io/themes/" target="_blank" rel="external">hexo themes</a>可以找到很多別人提供的框架<br>點選進去透過git clone 到 自己的themes 資料夾下面<br>修改_config.yml 下面theme 為clone 下來的資料夾名稱<br><strong>注意： 在theme: 後面要空一格 在填寫資料夾名稱</strong><br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">theme: hexo-theme-beantech</div></pre></td></tr></table></figure></p>
<p>重新啟動server這樣就可以看到框架的改變</p>
<h2 id="Themes-landscape-修改"><a href="#Themes-landscape-修改" class="headerlink" title="Themes landscape 修改"></a>Themes landscape 修改</h2><h3 id="修改Landscape-Header圖"><a href="#修改Landscape-Header圖" class="headerlink" title="修改Landscape Header圖"></a>修改Landscape Header圖</h3><p>在landscape 圖片是放在 landscape/source/css/images 下面<br>在landscape/source/css/_variables.styl 內有一行<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">banner-url = &quot;images/banner.jpg&quot;</div></pre></td></tr></table></figure></p>
<p>將圖片改名成你要的就可以了 建議圖片是長條延展這樣效果比較好</p>
<h3 id="修改網站-title-顯示的位置"><a href="#修改網站-title-顯示的位置" class="headerlink" title="修改網站 title  顯示的位置"></a>修改網站 title  顯示的位置</h3><p>在landscape/source/css/_partial/header.styl內有<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div></pre></td><td class="code"><pre><div class="line">#header-title</div><div class="line">  text-align: center</div><div class="line">  height: logo-size</div><div class="line">  position: absolute</div><div class="line">  top: 50%</div><div class="line">  left: 0</div><div class="line">  margin-top: logo-size * -0.5</div></pre></td></tr></table></figure></p>
<p>修改top value可以調整上下位置 修改left 正數為向右移 負數為向左移</p>
<h3 id="增加totop功能"><a href="#增加totop功能" class="headerlink" title="增加totop功能"></a>增加totop功能</h3><p>發現當文章比較長時,比較習慣有這個功能讓我快點切到最上面去轉換文章<br>Totop這個功能 在google大關鍵字就可找到範例程式<br><strong>但是我的blog透過fafeTo()這個功能是失敗的</strong> 最後找到目前可以work的方式<br>首先在增加檔案totop.ejs在<code>/layout/_partial</code> 內容爲<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">&lt;div id=&quot;totop&quot; style=&quot;position:fixed;bottom:30px;right:-50px;z-index:999;cursor:pointer;&quot;&gt;</div><div class="line">&lt;span style=&quot;color:#fff;background:#333;border-radius:3px;display:block;height:40px;width:40px;line-height:40px;text-align:center;&quot;&gt;TOP&lt;/span&gt;</div><div class="line">&lt;/div&gt;</div></pre></td></tr></table></figure></p>
<p>增加totop.js(jQuery file) 在<code>/source/js</code>下面 內容爲<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div><div class="line">6</div><div class="line">7</div><div class="line">8</div><div class="line">9</div><div class="line">10</div><div class="line">11</div><div class="line">12</div><div class="line">13</div><div class="line">14</div><div class="line">15</div></pre></td><td class="code"><pre><div class="line">(function($) &#123;</div><div class="line"> $(window).scroll(function()&#123;</div><div class="line">     if ($(window).scrollTop() &gt; 200)&#123;</div><div class="line">         $(&quot;#totop&quot;).stop().animate(&#123;right:&quot;5px&quot;&#125;);</div><div class="line">     &#125;else&#123;</div><div class="line">         $(&quot;#totop&quot;).stop().animate(&#123;right:&quot;-50px&quot;&#125;);</div><div class="line">     &#125;</div><div class="line"> &#125;);</div><div class="line"> $(&quot;#totop&quot;).click(function()&#123;</div><div class="line">     $(&apos;body,html&apos;).animate(&#123;</div><div class="line">         scrollTop:0</div><div class="line">     &#125;,300);</div><div class="line">     return false;</div><div class="line"> &#125;);</div><div class="line">&#125;)(jQuery);</div></pre></td></tr></table></figure></p>
<p>最後在<code>/layout/_partial/after-footer.ejs</code>的最後面加上<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">&lt;%- partial(&apos;totop&apos;) %&gt;</div><div class="line">&lt;%- js(&apos;js/totop&apos;) %&gt;</div></pre></td></tr></table></figure></p>
<p>這樣就可以了</p>
]]></content>
      
        <categories>
            
            <category> Blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[hexo startup]]></title>
      <url>/2017/05/12/hexo-startup/</url>
      <content type="html"><![CDATA[<p>透過<a href="https://hexo.io/zh-tw/docs/index.html" target="_blank" rel="external">Hexo</a>可以快速的建立一個blog<br>比Jekyll 好用的地方在tag部份跟有許多人提供他們修改過後的框架<br>但是透過github這邊去顯示網站的部份 不能透過git 去做版本控管<br>push 上去一定要透過<code>hexo deploy</code><br>不過Hexo 的相關文件比較齊全 又有中文支援 優勢蠻大的</p>
<h2 id="基本需求"><a href="#基本需求" class="headerlink" title="基本需求"></a>基本需求</h2><p>安裝Hexo 之前需要卻兩個軟體</p>
<ul>
<li>Node.js </li>
<li>Git </li>
</ul>
<p>安裝Node.js的方式網路上面都有說 這邊最主要說明ubuntu 下更新Node.js的方式<br>在ubuntu 15.04下面 試過<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line"># Using Ubuntu</div><div class="line">curl -sL https://deb.nodesource.com/setup_7.x | sudo -E bash -</div><div class="line">sudo apt-get install -y nodejs</div></pre></td></tr></table></figure></p>
<p>是失敗的 不會更新 最後是透過下面的方式更新成功<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div><div class="line">5</div></pre></td><td class="code"><pre><div class="line">sudo npm cache clean -f</div><div class="line">sudo npm install -g n</div><div class="line">sudo n stable</div><div class="line"></div><div class="line">sudo ln -sf /usr/local/n/versions/node/&lt;VERSION&gt;/bin/node /usr/bin/node</div></pre></td></tr></table></figure></p>
<p>要更再更新到最後的版本可以<code>sudo n latest</code><br>參考來源<a href="https://davidwalsh.name/upgrade-nodejs" target="_blank" rel="external">David Walsh blog</a></p>
<h4 id="注意-node-js版本不對時-會導致後面安裝hexo-失敗-有下面error-message"><a href="#注意-node-js版本不對時-會導致後面安裝hexo-失敗-有下面error-message" class="headerlink" title="注意 node.js版本不對時 會導致後面安裝hexo 失敗  有下面error message"></a>注意 node.js版本不對時 會導致後面安裝hexo 失敗  有下面error message</h4><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install errors with Error: ENOENT, chmod</div></pre></td></tr></table></figure>
<h2 id="hexo-安裝-and-相關指令"><a href="#hexo-安裝-and-相關指令" class="headerlink" title="hexo 安裝 and 相關指令"></a>hexo 安裝 and 相關指令</h2><p>透過npm 安裝<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">sudo npm install -g hexo-cli</div></pre></td></tr></table></figure></p>
<p>安裝後的相關檔案在/usr/local/n/versions/node/<version>/lib/node_modules</version></p>
<h4 id="建立"><a href="#建立" class="headerlink" title="建立"></a>建立</h4><p>透過下面指令可以建立一個基本的所需的檔案<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div></pre></td><td class="code"><pre><div class="line">hexo init &lt;folder&gt;</div><div class="line">cd &lt;folder&gt;</div><div class="line">npm install</div></pre></td></tr></table></figure></p>
<p>在<folder>專案內大致上有這些<br><img src="/images/hexo_1.png" alt="file_list"></folder></p>
<ul>
<li><p>_config.yml 是網站配置設定<br><strong>注意 這邊的修改 在 “:” 之後都要空一格 格式上面要注意 才不會server啟動之後有問題</strong></p>
</li>
<li><p>source資料夾下面會產生基本的hexo layout 的資料夾名稱_posts _drafts<br>Hexo 有三種預設佈局：post、page 和 draft，它們分別對應不同的路徑<br><img src="/images/hexo_2.png" alt="path"></p>
</li>
</ul>
<p>相關的放置文章的地方就在這幾個資料夾下面<br><strong>這邊要注意 放置網頁的圖片不能放在這幾個資料夾下面 需要另外建立一個地方放置</strong><br>例如source/images 要不然會找不到<br>另外加入圖片markdown 這邊寫法是<br> <code>![path](/images/hexo_2.png)</code><br>後面path路徑是base 在source folder 下面</p>
<ul>
<li>themes  這邊是放相關網站要用的框架 default 是landscape<br>你可以透過網路上下載想要的框架放在themes folder下面<br>修改_config.yml 下面的名稱 改成對應的資料夾<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line"># Extensions</div><div class="line">theme: landscape</div></pre></td></tr></table></figure>
</li>
</ul>
<h4 id="指令"><a href="#指令" class="headerlink" title="指令"></a>指令</h4><p><code>hexo init [folder]</code> 建立一個新的網站<br><code>hexo new [layout] &lt;tiltle&gt;</code> 產生一篇新的文章 default layout 是用_config.yml的default_layout<br><code>hexo server</code> 啟動server 透過localhost:4000可以看到,可以縮寫成<code>hexo s</code><br><code>hexo generate</code> 產生靜態檔案 放到hithub 上面需要的, 部署網站前先產生靜態檔案,可以縮寫成<code>hexo g</code><br><code>hexo clean</code>  清除快取檔案 (db.json) 和已產生的靜態檔案 (public), 建議在generate 前先做一次clean<br><code>hexo deploy</code> 會將靜態檔案push到遠端的server<br>deploy設定在_config.yml內<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line"># Deployment</div><div class="line">## Docs: https://hexo.io/docs/deployment.html</div><div class="line">deploy:</div><div class="line">  type:</div></pre></td></tr></table></figure></p>
<h4 id="發佈到github上面"><a href="#發佈到github上面" class="headerlink" title="發佈到github上面"></a>發佈到github上面</h4><p>要push 到git 上面需要先安裝hexo-deployer-git<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">npm install hexo-deployer-git --save</div></pre></td></tr></table></figure></p>
<p>如果想要透過<git_account>.github.io連到自己的網站<br>需要在github上面建立<git_account>.github.io名稱的repository<br>再將repository 位置改成它</git_account></git_account></p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div><div class="line">3</div><div class="line">4</div></pre></td><td class="code"><pre><div class="line">deploy:</div><div class="line">  type: github</div><div class="line">  repository: git@github.com:github帳號/github帳號.github.com.git</div><div class="line">  branch: master</div></pre></td></tr></table></figure>
<p>這邊push是透過ssh認證 需要在github加上你的ssh key<br>deploy之後需要等待3-5分鐘github上面會更新</p>
<p>其他詳細的資訊可以透過<a href="https://hexo.io/zh-tw/docs/index.html" target="_blank" rel="external">Hexo</a>找尋</p>
]]></content>
      
        <categories>
            
            <category> Blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> hexo </tag>
            
        </tags>
        
    </entry>
    
    <entry>
      <title><![CDATA[利用Jekyll與Github Page建立自己的 Blog]]></title>
      <url>/2017/04/27/2017-04-27-jekyll-github/</url>
      <content type="html"><![CDATA[<p>因爲看到同事利用Blog當作自己的筆記 覺得蠻好用的 所以想要自己架一個<br>觀察他的blog發現竟然是github.io 讓我好奇如何用 Github 可以當作一個免費的平臺架站<br>主要是找到幾個人分享的資料 這邊來做個記錄</p>
<p><a href="http://seans.tw/2016/make-own-blog-with-jekyll-and-github-page/" target="_blank" rel="external">利用Jekyll與Github Page建立自己的Dev-Blog</a><br><a href="https://rhadow.github.io/2015/02/18/Jekyll-x-Github-x-Blog-Part1/" target="_blank" rel="external">Jekyll x Github x Blog</a></p>
<p>其實目前可以常見跟github結合的有 wordpress, hexo, jekyll<br>會選擇jekyll 是因爲github上面推薦的</p>
<p>但是在遇到tags部份的處理之後 覺得hexo比較好用 後來就改用hexo<br>可是在版本控管 Jekyll還是有優勢 可以直接享受 Github 本來就有提供的版本控制功能</p>
<h2 id="Jekyll基本安裝"><a href="#Jekyll基本安裝" class="headerlink" title="Jekyll基本安裝"></a>Jekyll基本安裝</h2><p>Jekyll是base on ruby 開發 需要的版本要ruby2.0以上</p>
<p>在ubuntu下 當系統已經安裝不合版本的ruby時需要更新<br><code>ruby -v</code> check version<br><figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div><div class="line">2</div></pre></td><td class="code"><pre><div class="line">luna@luna-ubuntu14:blog$ ruby -v</div><div class="line">ruby 2.0.0p384 (2014-01-12) [x86_64-linux-gnu]</div></pre></td></tr></table></figure></p>
<p>可以直接透過<code>apt-get install ruby2.0 ruby2.0-dev</code> 安裝2.0版本<br>我們需要dev 因爲在安裝Jekyll時會自己做編譯的動作<br>在安裝之後需要將原本相關執行檔的link 重新連結 這樣才會用到對的版本透過下面command<br>    update-alternatives –install /usr/bin/ruby ruby /usr/bin/ruby-2.0 400 \<br>     –slave /usr/bin/rake rake /usr/bin/rake2.0 \<br>     –slave /usr/bin/ri ri /usr/bin/ri2.0 \<br>     –slave /usr/bin/rdoc rdoc /usr/bin/rdoc2.0 \<br>     –slave /usr/bin/gem gem /usr/bin/gem2.0 \<br>     –slave /usr/bin/irb irb /usr/bin/irb2.0</p>
<p>可以再透過<code>ruby -v</code> or <code>gem -v</code>確認抓到的版本是不是最新的</p>
<p><a href="https://jekyllrb.com/" target="_blank" rel="external">Jekyll 官方網站</a>目前release 版本到3.x 最基本的安裝方式如下</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">gem install jekyll bundler</div></pre></td></tr></table></figure>
<p>安裝之後再透過下面command可以產生最基本的檔案在my-Blog資料夾</p>
<figure class="highlight plain"><table><tr><td class="gutter"><pre><div class="line">1</div></pre></td><td class="code"><pre><div class="line">jekyll new my-Blog</div></pre></td></tr></table></figure>
<p>執行方式是進入my-Blog資料夾內 run <code>bundle exec jekyll serve</code><br>或是 <code>jekyll build</code> 先去建立_site之後 run <code>jekyll serve</code><br>透過browse 打 <a href="http://localhost:4000" target="_blank" rel="external">http://localhost:4000</a> 就可以看到最基本的網站</p>
<h2 id="透過Github-建立自已的網站"><a href="#透過Github-建立自已的網站" class="headerlink" title="透過Github 建立自已的網站"></a>透過Github 建立自已的網站</h2><p>Github有一個Pages的服務，讓你可以把自己的靜態網頁丟到Github上。<br>使用Jekyll只要把整包產出來的檔案直接Push到Github上就可以<br>但如果想要透過account.github.io 這個位置可以連到自己的網站<br>需要在 Githubg上面建立一個repo名稱是account.github.io (這邊的account是自己的帳號名稱)<br>並卻定branch是在master上面,接下來將剛剛的my-Blog push上去就好了</p>
<pre><code>cd my-Blog
git remote add origin https://github.com/account/account.github.io.git
git push -u origin master
</code></pre><p>然後你可透過 browse 登入 <a href="http://account.github.io.git" target="_blank" rel="external">http://account.github.io.git</a> </p>
]]></content>
      
        <categories>
            
            <category> Blog </category>
            
        </categories>
        
        
        <tags>
            
            <tag> jekyll </tag>
            
        </tags>
        
    </entry>
    
  
  
</search>
